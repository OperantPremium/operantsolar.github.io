#!/usr/bin/perl -w

# (C) 2017 Operant Solar
# All rights reserved
#
# @author: Walter Coole <walter.coole@operantsolar.com>

use strict;
use warnings;
use Date::Format;
use Date::Manip;
use File::Basename;
use Getopt::Std;
use Date::Format;
use POSIX "fmod";
use Text::CSV;

use vars qw(%unitRecords $opt_D $opt_f $opt_l $opt_n $opt_s $start $finish $logEpoch %receptions %forwards %nonceFilter %nonceTimes);
 # table of (implied) start times for each unit's Atmel timer

use vars qw($true $false);
$true = 1;
$false = 0;

getopt('fns');
if (defined($opt_f)) {
    $finish = UnixDate(ParseDate($opt_f), "%s");
} else {
    $finish = time;
}
if (defined($opt_n)) {
    @nonceFilter{split(',', $opt_n)} = undef;
}
if (defined($opt_s)) {
    $start = UnixDate(ParseDate($opt_s), "%s");
} else {
    $start = 0;
}

my @linesNotUnderstood;
my @logChunks;
FILE: foreach my $filename (@ARGV) {
  my $unit = substr(basename($filename, ".log"), 0, 5);
  if (not exists $unitRecords{$unit} ) {
      $unitRecords{$unit} = {};
  }
  open(FILE, $filename) or die $!;
  my @lines;
  while (<FILE>) {
    chomp; # Drop trailing newline
    s/\s*$//; # and other whitespace
    s/^(?:(?:\W+\w+\W+\w{2}Contacting\sthe\simpCloud)*\W+\w+\W+\w{2})?//;
    push @lines, $_;
  }
  my $inputLine = 0;
  my $dateRE = qr/^(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\s[-\w]{3,5}\s+/;
  my $aspectRE = qr/\[(\w{5,6})\]\s+/;
  while (1) {
    if ($inputLine >= scalar(@lines)) {
	last;
    }
    do {
	$_ = $lines[$inputLine++];
	if (not /<LOG>.*<\/LOG>/ and /<\/LOG>/) {
	    warn "Missing opening LOG tag: $_";
	}
    } while ( not /<LOG>/ and $inputLine < scalar(@lines));
    my $logChunk;
    if (/$dateRE$aspectRE/) { # grab the logged date, lopping off the timezone
      	my $logDate = ParseDate($1);
	$logEpoch = UnixDate($logDate, "%s");
	$logChunk = $'; # extra ' character to close quoted string
    } elsif ( /^ERROR: undefined$/  ) { # logging flaw
	next;
    } elsif ( /^ERROR: Service Unavailable: Back-end server is at capacity$/  ) { # logging flaw
	next;
    } else {
	die "expected time stamp";
    }
    while ( not $logChunk =~ /<\/LOG>/ and $inputLine < scalar(@lines) ) {
        $_ = $lines[$inputLine++];
	if (/<LOG>/) {
	    warn "Missing closing LOG tag: $logChunk";
	    $logChunk = $_;
	} elsif (/$dateRE$aspectRE/) {
	    $logChunk .= $'; # extra ' character to close quoted string
	} else {
	    die "expected time stamp";
        }
    }
    push @logChunks, {text=>$logChunk, time=>$logEpoch, unit=>$unit};
  }
}
foreach my $chunk (@logChunks) {
  my %partialEvent;
  $_ = $$chunk{text};
  s/<DBUG>.*?<\/DBUG>//g;
  if ( /<LOG>.*<LOG>.*<\/LOG>/ ) {
      warn "Malformed LOG tags: $_";
  } elsif ( /<DVID>(.*)<\/DVID>/ ) {
      $unitRecords{$$chunk{unit}}{macAddress} = substr($1, -6, 6);
  } elsif ($$chunk{time} < $start ) {
      next; # before our time window
  } elsif ($$chunk{time} > $finish ) {
      next; # after our time window
  } elsif ( /<RTIM>(.*)<\/RTIM>/ ) {
      $partialEvent{millis} = $1;
      my $receiveTime = $$chunk{time}; # TODO: correct time
      if ( /<SENT>(.*)<\/SENT>/ ) {
	  $partialEvent{origin} = $1;
      }
      $partialEvent{stamp} = $receiveTime;
      if ( /<INT>(.*)<\/INT>/ ) {
	  $partialEvent{interest} = $1;
	  if ( /<FACE>.*<\/FACE><FACE>(.*)<\/FACE>.*<FACE>.*<\/FACE>/ and $1 eq "internal://app" ) {
	      $partialEvent{eventType} = "produce";
	  } elsif ( /<DROP>.*<\/DROP>/ ) {
              $partialEvent{eventType} = "drop interest";
	  } else {
	      $partialEvent{eventType} = "forward interest";
	  }
      }
      if ( /<NONC>(.*?)<\/NONC>/ ) {
	  my $nonce = $1;
	  $partialEvent{nonce} = $nonce;
	  if (not defined($nonceTimes{$nonce}) ) {
	      $nonceTimes{$nonce} = $$chunk{time};
	  }
      }
      if ( /<DATA>.*<\/DATA>/ ) {
	  if ( /<DROP>.*<\/DROP>/ ) {
              $partialEvent{eventType} = "drop data";
	  } elsif ( /<FACE>(.*)<\/FACE><FACE>(.*)<\/FACE>/ ) {
	      if ( $2 eq "internal://agent" ) {
		  $partialEvent{eventType} = "consume";
	      } else {
		  $partialEvent{eventType} = "forward data";
	      }
	  } else {
	      $partialEvent{eventType} = "forward data";
	      if ( /<DATA>.*<\/DATA>.*<NONCE>(.*)<\/NONCE>/ ) {
		  $partialEvent{nonce} = $1;
	      }
	  }
      }
      if ( /<BLOK>.*<\/BLOK>/ ) {
	  $partialEvent{eventType} = "block";
      }
  } elsif ( /<INT>(.*)<\/INT>/ ) {
      $partialEvent{origin} = $unitRecords{$$chunk{unit}}{macAddress};
      if ( /<FACE>.*<\/FACE>.*<FACE>internal:\/\/agent<\/FACE>/ ) {
	  $partialEvent{eventType} = "consume";
      } else {
	  $partialEvent{eventType} = "express";
      }
      $partialEvent{stamp} = $$chunk{time};
      $partialEvent{interest} = $1;
      if ( /<NONC>(.*)<\/NONC>/ ) {
	  my $nonce = $1;
	  $partialEvent{nonce} = $nonce;
	  if (not defined($nonceTimes{$nonce}) ) {
	      $nonceTimes{$nonce} = $$chunk{time};
	  }
      }
  }
  if (%partialEvent) {
      use vars qw($stamp);
      if (not defined($unitRecords{$$chunk{unit}}{macAddress})) {
	  $unitRecords{$$chunk{unit}}{macAddress} = $$chunk{unit};
      }
      $partialEvent{reporter} = $unitRecords{$$chunk{unit}}{macAddress};
      $stamp = $partialEvent{stamp};
      my %receptionFilter = ('produce' => undef,
			     "forward interest" => undef,
			     "forward data" => undef,
			     "drop interest" => undef,
			     "block" => undef,
			     'consume' => undef,
      );
      if (exists($receptionFilter{$partialEvent{eventType}}) ) {
	  while (exists($receptions{$$chunk{unit}}{$stamp})) {
	      $stamp += 0.001;
	  }
	  $receptions{$$chunk{unit}}{$stamp} = {};
	  while (my ($kk, $vv) = each %partialEvent ) {
	      $receptions{$$chunk{unit}}{$stamp}{$kk} = $vv;
	  }
      }
      my %forwardFilter = ('produce' => undef,
			   "forward interest" => undef,
			   "express" => undef,
			   "forward data" => undef,
			   "drop interest" => undef,
			   'consume' => undef,
      );
      if (exists($forwardFilter{$partialEvent{eventType}}) ) {
	  while (exists($forwards{$$chunk{unit}}{$stamp})) {
	      $stamp += 0.001;
	  }
	  $forwards{$$chunk{unit}}{$stamp} = {};
	  while (my ($kk, $vv) = each %partialEvent ) {
	      $forwards{$$chunk{unit}}{$stamp}{$kk} = $vv;
	  }
      }
  }
}

if (defined($opt_l)) { # just print the list

    sub byTime {
        $nonceTimes{$a} <=> $nonceTimes{$b}
    }

    foreach my $nonce (sort byTime keys(%nonceTimes)) {
        print time2str("%H:%M:%S", $nonceTimes{$nonce}), ": $nonce\n";
    }
    exit(0);
}

my %stampList;
my @nodeKeys = sort(keys(%unitRecords));
foreach my $node (@nodeKeys) {
    if (defined($receptions{$node})) {
	@stampList{keys($receptions{$node})} = (undef) x keys($receptions{$node});
    }
    if (defined($forwards{$node})) {
	@stampList{keys($forwards{$node})} = (undef) x keys($forwards{$node});
    }
}
use vars qw($summary $headers $rowCount $maxNodes %unitMap);
while ( my ($key, $record) = each %unitRecords ) {
    if (defined($$record{macAddress})) {
	$unitMap{$$record{macAddress}} = $key;
    }
}

foreach my $stamp (sort(keys(%stampList))) {
    my $offsetCount = 0;
    while ( my ($unit, $record) = each %unitRecords ) {
	if (defined($$record{offset})) {
	    $offsetCount ++;
	}
    }
    if ($offsetCount >= scalar(@ARGV) ) { # we have an offest for each input file
	last;
    }
    my $nodeCount = 0;
    foreach my $node (@nodeKeys) {
	if (defined($receptions{$node}{$stamp}) and defined($receptions{$node}{$stamp}{millis})) {
	    $nodeCount++;
	}
    }
    if ($nodeCount < 2) {
	next;
    }
    my %key;
    foreach my $node (@nodeKeys) {
	if (defined($receptions{$node}{$stamp}) and defined($receptions{$node}{$stamp}{millis}) and defined($unitRecords{$node}{offset}) ) {
	    %key = (offset => $unitRecords{$node}{offset},
		    millis => $receptions{$node}{$stamp}{millis},
		    interest => $receptions{$node}{$stamp}{interest},
		    nonce => $receptions{$node}{$stamp}{nonce},
		    origin => $receptions{$node}{$stamp}{origin});
	    last;
	}
    }
    if ( not %key) {
	foreach my $node (@nodeKeys) {
	    if (defined($receptions{$node}{$stamp}) and defined($receptions{$node}{$stamp}{millis}) and not defined($unitRecords{$node}{offset}) ) {
		$unitRecords{$node}{offset} = $stamp - $receptions{$node}{$stamp}{millis} / 1000;
		%key = (offset => $unitRecords{$node}{offset},
			millis => $receptions{$node}{$stamp}{millis},
			interest => $receptions{$node}{$stamp}{interest},
			nonce => $receptions{$node}{$stamp}{nonce},
			origin => $receptions{$node}{$stamp}{origin});
		last;
	    }
	}
    }
    foreach my $node (@nodeKeys) {
	if (defined($receptions{$node}{$stamp}) and defined($receptions{$node}{$stamp}{millis}) and not defined($unitRecords{$node}{offset}) ) {
	    if ( $key{origin} eq $receptions{$node}{$stamp}{origin} ) {
		$unitRecords{$node}{offset} = $key{offset} + ($key{millis} - $receptions{$node}{$stamp}{millis}) / 1000 ;
	    }
	}
    }
}
$maxNodes = 10;

$summary = Text::CSV->new({ eol => $/ });
$rowCount = 1;
if (defined($opt_n)) {
    $summary->print(*STDOUT, ["nonce selected:", join(",", keys(%nonceFilter)), ("") x (scalar(@nodeKeys) + 5)]) or die;
} else {
    $summary->print(*STDOUT, ["nonce selected:", "ALL", ("") x (scalar(@nodeKeys) + 5)]) or die;
}
$rowCount++;
$summary->print(*STDOUT, [("") x (scalar(@nodeKeys) + 7)]) or die;
$rowCount++;
$summary->print(*STDOUT, ["", @nodeKeys, ("") x 5]) or die;
$rowCount++;


foreach my $stamp (sort(keys(%stampList))) {
    my $originRow = ["RX FROM"];
    my $timeRow = ["RX TIME"];
    foreach my $node ( @nodeKeys ) {
	my $goFlag = exists($receptions{$node}{$stamp});
	if (defined($opt_n) and $goFlag) {
	    $goFlag = ( exists($receptions{$node}{$stamp}{nonce}) and exists($nonceFilter{$receptions{$node}{$stamp}{nonce}}) );
	}
	if ($goFlag) {
	    if ( not defined($receptions{$node}{$stamp}{origin}) ) {
		print "trouble\n";
	    }
	    push $originRow, $unitMap{$receptions{$node}{$stamp}{origin}};
	    if ( defined($receptions{$node}{$stamp}) and defined($receptions{$node}{$stamp}{millis}) ) {
		my $precisionStamp = $unitRecords{$node}{offset} + $receptions{$node}{$stamp}{millis} / 1000;
		my $fractionalPart = substr(sprintf('%.2f', fmod($precisionStamp, 1)), 1);
		push $timeRow, time2str("%Y-%m-%d %T$fractionalPart %Z", $precisionStamp);
	    } else {
		push $timeRow, time2str("%Y-%m-%d %T %Z", $stamp);
	    }
	} else {
	    push $originRow, "";
	    push $timeRow, "";
	}
    }

    my $eventRow = ["ACTION"];
# Randy might want this back    my $eventTimeRow = ["", "Time:"];
    foreach my $node ( @nodeKeys ) {
	my $goFlag = exists($forwards{$node}{$stamp});
	if (defined($opt_n) and $goFlag) {
	    if (exists($forwards{$node}{$stamp}{nonce}) ) {
		$goFlag = exists($nonceFilter{$forwards{$node}{$stamp}{nonce}});
	    } else {
		$goFlag = 0;
	    }
	}
	my %handleMap = ('produce' => 'PRODUCE',
			 'forward interest' => 'FORWARD INTEREST',
			 'forward data' => 'FORWARD DATA',
			 "express" => "EXPRESS",
			 'drop interest' => 'DROP',
			 'consume' => 'CONSUME',
	    );
#	my %typeMap = ('produce' => 'Data',
#		       'forward interest' => 'Interest',
#		       'drop interest' => 'Interest',
#		       "express" => 'Interest',
#		       'forward data' => 'Data',
#		       'consume' => 'Data',
#	    );
	if ( $goFlag and exists($handleMap{$forwards{$node}{$stamp}{eventType}}) ) {
	    push $eventRow, $handleMap{$forwards{$node}{$stamp}{eventType}};
#	    push $typeRow, $typeMap{$forwards{$node}{$stamp}{eventType}};
#	    my $fractionalPart = substr(sprintf('%.2f', fmod($stamp, 1)), 1);
#	    push $eventTimeRow, time2str("%Y-%m-%d %T$fractionalPart %Z", $stamp);
	} else {
	    push $eventRow, "";
#	    push $typeRow, "";
#	    push $eventTimeRow, "";
	}
    }
    if ( ( join("", @$originRow) ne join("", "RX FROM", ("") x 5 ) ) or
	 ( join("", @$eventRow) ne join("", "ACTION", ("") x 5 ) ) ) {
	$summary->print(*STDOUT, $originRow) or die;
	$rowCount++;
	
	$summary->print(*STDOUT, $timeRow) or die;
	$rowCount++;
	$summary->print(*STDOUT, $eventRow) or die;
	$rowCount++;
	$summary->print(*STDOUT, [("") x (scalar(@nodeKeys) + 7)]) or die;
	$rowCount++;
    }

#    push $typeRow, (("") x 5);
#    $summary->print(*STDOUT, $typeRow) or die;
#    $rowCount++;

#    push $eventTimeRow, (("") x 5);
#    $summary->print(*STDOUT, $eventTimeRow) or die;
#    $rowCount++;
}

